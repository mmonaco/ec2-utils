#!/usr/bin/env python2

# This file is part of ec2-utils.
#
# Copyright 2012 Matthew Monaco
#
# ec2-utils is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ec2-utils is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ec2-utils.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import os, re, sys, argparse, subprocess
import boto, boto.ec2.connection, boto.ec2.regioninfo

USAGE = """\
usage: main [-h|--help] [options] <command> [<args>]

  An EC2 tool

  ec2 ls [-d] [<instance-id>...]
      List all instances.
      -d  Dump information in a line-separated format.

  ec2 lsimg
      List images.

  ec2 keys
      List keypairs.

  ec2 sg [-d] [<group>...]
      List security groups
      -d Dump multi-line information.

  ec2 mksg <name> <description>
      Create a new security group.

  ec2 chsg [-d] <name> <proto> <srcport> [<dstport>]
      Add a rule to security group
      -d Delete rule

  options:
    -h, --help         print this message and exit
    -o, --openstack    source ~/.ec2-novarc (default)
    -e, --eucalyptus   source ~/.ec2-eucarc

"""

def _argparse():

	p = argparse.ArgumentParser()

	p.print_help   = lambda fd=sys.stdout : fd.write(USAGE)
	p.print_usage  = lambda fd=sys.stdout : fd.write(USAGE)
	p.format_help  = lambda : S3_USAGE
	p.format_usage = lambda : S3_USAGE

	p.add_argument("-o", "--openstack", dest="rc",
		action="store_const", const="~/.ec2-novarc", default="~/.ec2-novarc")
	p.add_argument("-e", "--eucalyptus", dest="rc",
		action="store_const", const="~/.ec2-eucarc")

	s = p.add_subparsers(dest="cmd")

	p_ls = s.add_parser("ls")
	p_ls.add_argument("instance_ids", nargs="*", type=str)
	p_ls.add_argument("-d", "--dump", action="store_true")

	p_lsimg = s.add_parser("lsimg")

	p_keys = s.add_parser("keys")

	p_sg = s.add_parser("sg")
	p_sg.add_argument("names", nargs="*", type=str)
	p_sg.add_argument("-d", "--dump", action="store_true")

	p_mksg = s.add_parser("mksg")
	p_mksg.add_argument("name")
	p_mksg.add_argument("desc")

	p_chsg = s.add_parser("chsg")
	p_chsg.add_argument("name", type=str)
	p_chsg.add_argument("proto", type=str, choices=("tcp", "udp", "icmp"))
	p_chsg.add_argument("srcport", type=int)
	p_chsg.add_argument("dstport", type=int, nargs="?", default=None)
	p_chsg.add_argument("-d", "--delete", action="store_true")

	args = p.parse_args()
	return args


def _source_env(filename=None):

	if filename is None:
		return

	cmd = ["sh", "-c", "source %s && env" % filename]
	prc = subprocess.Popen(cmd, stdout=subprocess.PIPE)

	for line in prc.stdout:

		if line[-1] == '\n':
			line = line[:-1]

		key, _, val = line.partition("=")

		os.environ[key] = val

	prc.communicate()


def _parse_url(url):

	m = re.match("http://(.+):(\d+)(/.+)?", url)

	if m and m.lastindex >= 2:
		host = m.group(1)
		port = int(m.group(2))
		path = m.group(3) if m.group(3) else "/"
	else:
		raise Exception("parse_url: bad input '%s'" % url)

	return host, port, path


def _cxn_from_env():

	ec2_access = os.getenv("EC2_ACCESS_KEY")
	ec2_secret = os.getenv("EC2_SECRET_KEY")
	ec2_url    = os.getenv("EC2_URL")

	ec2_host, ec2_port, ec2_path = _parse_url(ec2_url)

	region = boto.ec2.regioninfo.RegionInfo()
	region.endpoint = ec2_host

	cxn = boto.ec2.connection.EC2Connection(
		aws_access_key_id=ec2_access,
		aws_secret_access_key=ec2_secret,
		port=ec2_port,
		path=ec2_path,
		is_secure=False,
		region=region
		)

	return cxn


def _str_sg_rule(r):

	s  = str(r.ip_protocol)
	s += ":" + str(r.from_port)
	if r.from_port != r.to_port:
		s += ":" + str(r.to_port)
	return s


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Sub Commands
#

def ec2_ls_instance(r, i, dump=False):

	pubname = i.public_dns_name if i.public_dns_name else i.ip_address
	priname = i.private_dns_name if i.private_dns_name else i.private_ip_address

	if dump:
		keys = sorted(i.__dict__.keys())
		for k in keys:
			print("%-20s = %s" % (k, i.__dict__[k]))
		print("")
	else:
		print("%s %s [%-7s] %-15s %-15s %s   %s" % (
			r.id, i.id, i.state, pubname, priname, i.image_id, i.key_name))


def ec2_ls_instances(cxn, instance_ids, dump=False):

	reservations = cxn.get_all_instances(instance_ids=instance_ids)
	lst = []
	for r in reservations:
		for i in r.instances:
			i._resrv_ = r
		lst.extend(r.instances)

	lst.sort(key=lambda x: x.id)

	for i in lst:
		ec2_ls_instance(i._resrv_, i, dump)


def ec2_ls_image(i):

	print("%s %s [%s] %s %12s %12s %s" % (
		i.id, i.owner_id, i.state, i.root_device_name, i.kernel_id,
		i.ramdisk_id, i.location))



def ec2_ls_image(i):

	print("%s %s [%s] %s %12s %12s %s" % (
		i.id, i.owner_id, i.state, i.root_device_name, i.kernel_id,
		i.ramdisk_id, i.location))


def ec2_ls_images(cxn):

	imgs = cxn.get_all_images()
	for i in imgs:
		ec2_ls_image(i)


def ec2_ls_keys(cxn):

	keys = cxn.get_all_key_pairs()
	for k in keys:
		print("%s  %s" % (k.name, k.fingerprint))


def ec2_ls_security_groups(cxn, names=None, dump=False):

	lst = cxn.get_all_security_groups(groupnames=names)
	for cg in lst:
		if dump:
			keys = sorted(cg.__dict__.keys())
			for k in keys:
				print("%-20s = %s" % (k, cg.__dict__[k]))
			print("")
		else:
			print("%-15s" % (cg.name), end="")
			for r in cg.rules:
				print(" %s" % _str_sg_rule(r), end="")
			print()


def ec2_create_security_group(cxn, name, desc):

	kp = cxn.create_security_group(name, desc)
	print("created new sg %s - %s" % (kp, kp.name))


def ec2_edit_security_group(cxn, name, proto, srcport, dstport=None, rm=False):

	if not dstport:
		dstport=srcport

	cg = cxn.get_all_security_groups(groupnames=[name])
	assert len(cg) == 1
	cg = cg[0]
	if rm:
		cg.revoke(proto, srcport, dstport)
	else:
		cg.authorize(proto, srcport, dstport)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Main
#

if __name__ == "__main__":

	args = _argparse()

	if args.rc:
		_source_env(args.rc)

	cxn = _cxn_from_env()

	if args.cmd == "ls":
		ec2_ls_instances(cxn, args.instance_ids, args.dump)

	elif args.cmd == "lsimg":
		ec2_ls_images(cxn)

	elif args.cmd == "keys":
		ec2_ls_keys(cxn)

	elif args.cmd == "sg":
		ec2_ls_security_groups(cxn, args.names, args.dump)

	elif args.cmd == "mksg":
		ec2_create_security_group(cxn, args.name, args.desc)

	elif args.cmd == "chsg":
		ec2_edit_security_group(cxn, args.name, args.proto, args.srcport,
			args.dstport, args.delete)
